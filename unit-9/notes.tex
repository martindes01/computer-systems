\subsection{Early Computers}

Early computers used magnetic tape decks for storage and used paper tape for input and output.
Each program was keyed in by hand to control the required system function.
There was a distinct lack of monitors.
The `operators' controlled the loading of magnetic tapes, fed in cards and paper tape, and maintained the system.
This `operation' was laborious, expensive, tedious and error-prone.

As computers became faster and more powerful, the role of the operators became a limiting factor.
An automated system was required to free the operators from the mundane tasks.
Such a system is known as an `operating system'.

\subsection{Operating System (OS)}

An operating system (OS) is a layer of system software that acts as an intermediary between a computer user and the underlying hardware.
The main function of an OS is to dynamically allocate the shared system resources to executing programs.

From the perspective of a user, the OS is designed for ease of use.
It provides a convenient interface for executing user programs, and hides the complexity of the hardware implementation.

From the perspective of the system, the OS is intimately involved with the hardware and acts as a resource manager for CPU time, memory, file storage, I/O devices etc.
Requests for these resources may be numerous and conflicting.
It also acts as a control system between I/O devices and user programs.
It manages the execution to prevent errors and improper use, such as one program attempting to view the memory of another.

\subsection{Components of a Computer System}

The main components of a computer system are the
\begin{itemize}
  \item hardware (the basic computing resources),
  \item operating system (controls and coordinates use of hardware),
  \item application programs (use the system resources to solve computing problems), and
  \item users (people, machines and other computers).
\end{itemize}

Services provided by the OS include
\begin{itemize}
  \item program development,
  \item program execution,
  \item access to I/O devices,
  \item access to files,
  \item system access,
  \item error detection and response, and
  \item accounting.
\end{itemize}
The most frequently used functions of the OS are stored in its `kernel'.

\subsection{Evolution of Operating Systems}

\subsubsection{Serial Processing}

Serial processing was used in the earliest computers.
This relied on human operators rather than an OS.
Users had access to the computer in `series'.

One problem with serial processing concerned scheduling.
Most installations used a sign-up sheet for the reservation of computer time.
Mistakes in the estimations of time allocations would result in wasted computer time.
A considerable amount of time was also spent simply setting up the program to run.

\subsubsection{Simple Batch Systems}

Since early computers were very expensive, it was important to maximise processor utilisation.
In simple batch systems, the user no longer had direct access to the processor.
Computer operators would batch jobs together and place them on an input device.
The loading of programs and management of jobs was handled by software known as a `monitor'.

The resident monitor always resides in memory.
After it reads in a job, the processor executes instructions from the memory containing the monitor until it reaches an error or ending condition.
Control then passes back to the monitor.

In this system, processor execution alternates between user programs and the monitor.
As a result, main memory and processor time is given to the monitor.
Despite this overhead, simple batch systems improved the utilisation of the processor.

\subsubsection{Multiprogrammed Batch Systems}

In uniprogrammed systems, the processor executes a program until it reaches an I/O instruction.
It must then wait for the I/O instruction to complete before it continues.

In multiprogrammed systems, when one jobs must wait for I/O to complete, the processor can switch to another job.

\subsubsection{Time Sharing Systems}

Time sharing systems are used to handle multiple interactive jobs.
Multiple users access the system simultaneously through terminals.
The OS interleaves the execution of each user program in short bursts or quanta of computation.

\begin{table}[htp]
  \centering
  \caption*{Comparison of multiprogrammed batch and time sharing systems.}
  \begin{tabular}{lll}
    \toprule
    Operating system & Principal objective & Source of directives \\
    \midrule
    Multiprogrammed batch & Maximise processor use & Commands provided with job \\
    Time sharing & Minimise response time & Commands entered at terminal \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection{Elements of an Operating System}

\subsubsection{Firmware}

A small `bootstrap' program is loaded when a computer is started.
This program is stored in read-only memory (ROM) or electrically erasable programmable read-only memory (EEPROM) so that it cannot easily be altered, either accidentally or maliciously.
The program is, therefore, known as `firmware'.

The bootstrap program initialises all CPU registers, device controllers and memory contents, and loads the OS kernel into memory.
Once the firmware is loaded, some services are provided outside the kernel.
These are loaded at boot time to become system processes or system `daemons', and run the entire time the kernel is running.
On Unix systems, the first system process is `init'.
Once all these processes are loaded, the OS waits for events to occur.

Events such as a user clicking a mouse button or a program attempting to access a file are known as `interrupts'.
Hardware may trigger an interrupt by sending a signal to the CPU.
Software triggers an interrupt by executing a special operation known as a `system call'.

The CPU reacts to an interrupt by suspending its current execution, immediately transferring execution to a fixed address (usually the starting address of the service routine for the interrupt), executes the interrupt service routine, and finally resumes execution where it was originally interrupted.

\subsubsection{Memory}

Memory is an array of bytes, in which each byte is addressable.
ROM cannot be modified.
EEPROM can be modified, but only infrequently.
The CPU requires memory that can be read and written.
It uses dynamic RAM (DRAM) and registers.

Main memory is erased when a machine powers off.
Secondary storage is used as a more permanent solution.
This includes magnetic and optical disks.

Data that is used frequently is stored in cache memory for faster access.
If the CPU requires data, the cache is checked first.

\subsubsection{Time Sharing}

The CPU can execute multiple jobs simultaneously by switching between the jobs stored in memory.
Switches occur so frequently that users can interact with each program as it is running.
CPU scheduling is used to decide which job is brought to memory to be executed when space is an issue.
Reasonable response time is of the utmost importance.

Processes can be swapped between main memory and the disk.
`Virtual memory' allows for the execution of a process that is not entirely in memory.
The process can use both virtual and physical memory as `logical' memory.
This allows users to run programs that require more than the available physical memory and frees programmers from concern over memory limitations.

\subsection{Dual Mode}

Operating system execution is split into user mode (mode bit of value \num{1}) and kernel mode (mode bit of value \num{0}).
In user mode, certain areas of memory are protected from user access, and certain instructions cannot be executed.
In kernel mode, protected areas of memory may be accessed, and privileged instructions may be executed.

The OS allows user programs to execute system calls by resetting the mode bit to \num{0}.
Once the kernel has executed the requested system call, the mode bit is set to \num{1}.
This prevents crashes in user mode from affecting the kernel.

The MS-DOS architecture has no mode bit.
Hence, user programs were able to wipe the entire OS, write to devices without permission, execute illegal instructions and access the memory of other users.
With dual mode, hardware can detect errors that violate modes and handle them with the help of the OS.

When a mode violation is detected, the OS must terminate the program, give an error message and produce memory dumps by writing to a file.

\subsection{System Calls}

System calls provide OS services to the user via an application programming interface (API).
The system call APIs are typically written in C or C++, though some are written in assembly language.

The system call for reading data from one file and writing it to another is \texttt{cp <file1> <file2>}.
This uses the following services.
\begin{itemize}
  \item Open \texttt{file1}
  \item Handle possible error
  \item Create \texttt{file2}
  \item Start read and write
  \item Handle possible errors
  \item Close \texttt{file1} and \texttt{file2}
\end{itemize}
The services are not accessed directly.
They are accessed via an API.

\begin{table}[htp]
  \centering
  \caption*{Examples of Windows and Unix system call APIs.}
  \begin{tabular}{lll}
    \toprule
    Type of call & Windows & Unix \\
    \midrule
    Process Control & \texttt{CreateProcess()}       & \texttt{fork()} \\
                    & \texttt{ExitProcess()}         & \texttt{exit()} \\
                    & \texttt{WaitForSingleObject()} & \texttt{wait()} \\
    File Manipulation & \texttt{CreateFile()}  & \texttt{open()}  \\
                      & \texttt{ReadFile()}    & \texttt{read()}  \\
                      & \texttt{WriteFile()}   & \texttt{write()} \\
                      & \texttt{CloseHandle()} & \texttt{close()} \\
    Device manipulation & \texttt{SetConsoleMode()} & \texttt{ioctl()} \\
                        & \texttt{ReadConsole()}    & \texttt{read()}  \\
                        & \texttt{WriteConsole()}   & \texttt{write()} \\
    Information maintenance & \texttt{GetCurrentProcessID()} & \texttt{getpid()} \\
                            & \texttt{SetTimer()}            & \texttt{alarm()}  \\
                            & \texttt{Sleep()}               & \texttt{sleep()}  \\
    Communication & \texttt{CreatePipe()}        & \texttt{pipe()}   \\
                  & \texttt{CreateFileMapping()} & \texttt{shmget()} \\
                  & \texttt{MapViewOfFile()}     & \texttt{mmap()}   \\
    Protection & \texttt{SetFileSecurity()}              & \texttt{chmod()} \\
               & \texttt{InitializeSecurityDescriptor()} & \texttt{umask()} \\
               & \texttt{SetSecurityDescriptorGroup()}   & \texttt{chown()} \\
    \bottomrule
  \end{tabular}
\end{table}

System call APIs specify a set of functions that are available to an application programmer.
They describe the parameters to pass to each function, and the values that are returned.
The programmer accesses the API via a library provided by the OS.

A Java API exists for programs that run on the JVM.
The JVM itself uses the system calls of its particular platform.

System call APIs are used for program portability.
A program using the API can be compiled and run on any system that supports the API.
Invoking system calls directly is usually more difficult.
Using a system call API is similar to implementing an interface.
